true := fn n => fn m => n;
false := fn n => fn m => m;
isZero := fn n => (fn x => false) true;
not := fn n => n false true;
pred := fn n => fn f => fn x => n ( fn g => fn h => h (g f))(fn u => x)(fn u => u);
two := fn f => fn x => f (f x);
one := pred two;
minus := fn n => fn m => m pred n;
less := fn n => fn m => not isZero minus m n;
succ := fn n => (fn f => fn x => f (n f x));
plus := fn n => (n succ);
four := plus two two;
Y := fn n => (fn m => n(m m))(fn m => n(m m));
fibrec := fn n => Y(fn m => (less n two)(n)(plus(f(fibrec pred n))(f(fibrec minus n two))));
main := fibrec four;