true := fn n => fn m => n;
false := fn n => fn m => m;
isZero := fn n => (fn x => false) true;
not := fn n => n false true;
pred := fn n => fn f => fn x => n ( fn g => fn h => h (g f))(fn u => x)(fn u => u);
two := fn f => fn x => f (f x);
one := pred two;
minus := fn n => fn m => m pred n;
less := fn n => fn m => not isZero minus m n;
succ := fn n => (fn f => fn x => f (n f x));
plus := fn n => (n succ);
four := plus two two;
Y := fn n => (fn m => n(m m))(fn m => n(m m));
fibrec := fn n => Y(fn m => (less n two)(n)(plus(f(fibrec pred n))(f(fibrec minus n two)));
main := fibrec four;


let
val x1 = "true"
val t1 = LM("n",LM("m",VA"n"))
val x2 = "false"
val t2 = LM("n",LM("m",VA"m"))
val x3 = "isZero"
val t3 = AP(LM("n",LM("x",VA"false")),VA"true")
val x4 = "not"
val t4 = LM("n",AP(VA"n",AP(VA"false",VA"true")))
val x5 = "pred"
val t5 = AP(AP(LM("n",LM("f",LM("x",AP(VA"n",LM("g",LM("h",AP(VA"h",AP(VA"g",VA"f")))))))),LM("u",VA"x")),LM("u",VA"u"))
val x6 = "two"
val t6 = LM("f",LM("x",AP(VA"f",AP(VA"f",VA"x"))))
val x7 = "one"
val t7 = AP(VA"pred",VA"two")
val x8 = "minus"
val t8 = LM("n",LM("m",AP(VA"m",AP(VA"pred",VA"n"))))
val x9 = "less"
val t9 = LM("n",LM("m",AP(VA"not",AP(VA"isZero",AP(VA"minus",AP(VA"m",VA"n"))))))
val x10 = "succ"
val t10 = LM("n",LM("f",LM("x",AP(VA"f",AP(VA"n",AP(VA"f",VA"x"))))))
val x11 = "plus"
val t11 = LM("n",AP(VA"n",VA"succ"))
val x12 = "four"
val t12 = AP(VA"plus",AP(VA"two",VA"two"))
val x13 = "Y"
val t13 = AP(LM("n",LM("m",AP(VA"n",AP(VA"m",VA"m")))),LM("m",AP(VA"n",AP(VA"m",VA"m"))))
val x14 = "fibrec"
val t14 = LM("n",AP(VA"Y",ApApLM("m",AP(VA"less",AP(VA"n",VA"two")))))
val t = AP(VA"fibrec",VA"four")
val main = AP(LM(x1,AP(LM(x2,AP(LM(x3,AP(LM(x4,AP(LM(x5,AP(LM(x6,AP(LM(x7,AP(LM(x8,AP(LM(x9,AP(LM(x10,AP(LM(x11,AP(LM(x12,AP(LM(x13,AP(LM(x14,t),t14)),t13)),t12)),t11)),t10)),t9)),t8)),t7)),t6)),t5)),t4)),t3)),t2)),t1)
val value = norReduce main
in
   print (pretty value)
end;